
# Maze generation algorithm

### From Wikipedia, the free encyclopedia

Jump to: navigation, search

<IMG>

This article may require cleanup to meet Wikipedia's quality standards. Please
improve this article if you can. (December 2006)  
There are a number of different maze generation algorithms, that is, automated
methods for the creation of mazes.

<IMG>

This maze generated by modified version of Prim's algorithm, below. Click the
Maze for Java source code.

## Contents

  * 1 Graph theory based methods
    * 1.1 Depth-first search
      * 1.1.1 Recursive backtracker
    * 1.2 Randomized Kruskal's algorithm
    * 1.3 Randomized Prim's algorithm
      * 1.3.1 Modified version
  * 2 Recursive division method
  * 3 Simple algorithms
  * 4 Non-cell-based algorithm
  * 5 See also
  * 6 External links

  
## [edit] Graph theory based methods

A maze can be generated by starting with a predetermined arrangement of cells
(most commonly a rectangular grid but other arrangements are possible) with
wall sites between them. This predeterimined arrangement can be considered as
a connected graph with the edges representing possible wall sites and the
nodes representing cells. The purpose of the maze generation algorithm can
then be considered to be making a subgraph where it is challanging to find a
route between two particular nodes.

If the subgraph is not connected, then there are regions of the graph that are
wasted because they do not contribute to the search space. If the graph
contains loops, then there may be multiple paths between the chosen paths.
Because of this, maze generation is often approached as generating a random
spanning tree. Loops which can confound naive maze solvers may be introduced
by adding random edges to the result during the course of the algorithm.

### [edit] Depth-first search

<IMG>

<IMG>

A maze running on a Palm emulator

This algorithm is a randomized version of the depth-first search algorithm.
Frequently implemented with a stack, this approach is one of the simplest ways
to generate a maze using a computer. Consider the space for a maze being a
large grid of cells (like a large chess board), each cell starting with four
walls. Starting from a random cell, the computer then selects a random
neighbouring cell that has not yet been visited. The computer removes the
'wall' between the two cells and adds the new cell to a stack (this is
analogous to drawing the line on the floor). The computer continues this
process, with a cell that has no unvisited neighbours being considered a dead-
end. When at a dead-end it backtracks through the path until it reaches a cell
with an unvisited neighbour, continuing the path generation by visiting this
new, unvisited cell (creating a new junction). This process continues until
every cell has been visited, causing the computer to backtrack all the way
back to the beginning cell. This approach guarantees that the maze space is
completely visited.

As stated, the algorithm is very simple and does not produce overly-complex
mazes. More specific refinements to the algorithm can help to generate mazes
that are harder to solve.

  1. Start at a particular cell and call it the "exit."
  2. Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor: 
    1. If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then recurse with that neighbor as the current cell.

As given above this algorithm involves deep recursion which may cause stack
overflow issues on some computer architectures. The algorithm can be
rearranged into a loop by storing backtracking information in the maze itself.
This also provides a quick way to display a solution, by starting at any given
point and backtracking to the exit.

Mazes generated with a depth-first search have a low branching factor and
contain many long corridors, which makes depth-first a good algorithm for
generating mazes in video games.

In mazes generated by that algorithm, it will typically be relatively easy to
find the way to the square that was first picked at the beginning of the
algorithm, since most paths lead to or from there, but hard to find the way
out.

#### [edit] Recursive backtracker

The depth-first search algorithm of maze generation is frequently implemented
using backtracking:

  1. Mark the current cell as 'Visited'
  2. If the current cell has any neighbours which have not been visited 
    1. Choose randomly one of the unvisited neighbours
    2. add the current cell to the stack
    3. remove the wall between the current cell and the chosen cell
    4. Make the chosen cell the current cell
    5. Recursively call this function
  3. else 
    1. remove the last current cell from the stack
    2. Backtrack to the previous execution of this function

### [edit] Randomized Kruskal's algorithm

This algorithm is simply a randomized version of Kruskal's algorithm.

  1. Create a list of all walls, and create a set for each cell, each containing just that one cell.
  2. For each wall, in some random order: 
    1. If the cells divided by this wall belong to distinct sets: 
      1. Remove the current wall.
      2. Join the sets of the formerly divided cells.

There are several data structures that can be used to model the sets of cells.
An efficient implementation using a disjoint-set data structure can perform
each union and find operation on two sets in nearly-constant amortized time
(specifically, O(Î±(V)) time; Î±(x) < 5 for any plausible value of x), so the
running time of this algorithm is essentially proportional to the number of
walls available to the maze.

It matters little whether the list of walls is initially randomized or if a
wall is randomly chosen from a nonrandom list, either way is just as easy to
code.

Because the effect of this algorithm is to produce a minimal spanning tree
from a graph with equally-weighted edges, it tends to produce regular patterns
which are fairly easy to solve.

### [edit] Randomized Prim's algorithm

This algorithm is a randomized version of Prim's algorithm.

  1. Start with a grid full of walls.
  2. Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.
  3. While there are walls in the list: 
    1. Pick a random wall from the list. If the cell on the opposite side isn't in the maze yet: 
      1. Make the wall a passage and mark the cell on the opposite side as part of the maze.
      2. Add the neighboring walls of the cell to the wall list.

Like the depth-first algorithm, it will usually be relatively easy to find the
way to the starting cell, but hard to find the way anywhere else.

Note that simply running classical Prim's on a graph with random weights would
create mazes stylistically identical to Kruskal's, because they are both
minimal spanning tree algorithms. Instead, this algorithm introduces stylistic
variation because the edges closer to the starting point have a lower
effective weight.

#### [edit] Modified version

Although the classical Prim's algorithm keeps a list of edges, for maze
generation we could instead maintain a list of adjacent cells. If the randomly
chosen cell has multiple edges that connect it to the existing maze, select
one of these edges at random. This will tend to branch slightly more than the
edge-based version above.

## [edit] Recursive division method

Illustration of Recursive Division original chamber division by two walls
holes in walls continue subdividing... completed  
<IMG> <IMG> <IMG> <IMG> <IMG>  
Mazes can be created with recursive division, an algorithm which works as
follows: Begin with the maze's space with no walls. Call this a chamber.
Divide the chamber with a randomly positioned wall (or multiple walls) where
each wall contain a randomly positioned passage opening within it. Then
recursively repeat the process on the subchambers until all chambers are
minimum sized. This method results in mazes with long straight walls crossing
their space, making it easier to see which areas to avoid.

For example, in a rectangular maze, build at random points two walls that are
perpendicular to each other. These two walls divide the large chamber into
four smaller chambers separated by four walls. Choose three of the four walls
at random, and open a one cell-wide hole at a random point in each of the
three. Continue in this manner recursively, until every chamber has a width of
one cell in either of the two directions.  

## [edit] Simple algorithms

Other algorithms exist that require only enough memory to store one line of a
2D maze or one plane of a 3D maze. They prevent loops by storing which cells
in the current line are connected through cells in the previous lines, and
never remove walls between any two cells already connected.

Most maze generation algorithms require maintaining relationships between
cells within it, to ensure the end result will be solvable. Valid simply
connected mazes can however be generated by focusing on each cell
independently. A binary tree maze is a standard orthogonal maze where each
cell always has a passage leading up or leading left, but never both. To
create a binary tree maze, for each cell flip a coin to decide whether to add
a passage leading up or left. Always pick the same direction for cells on the
boundary, and the end result will be a valid simply connected maze that looks
like a binary tree, with the upper left corner its root.

A related form of flipping a coin for each cell is to create an image using a
random mix of forward slash and backslash characters. This doesn't generate a
valid simply connected maze, but rather a selection of closed loops and
unicursal passages.

## [edit] Non-cell-based algorithm

A maze can also be generated without the use of cells. In year 2000, a
shareware called AmorphousMaze, appeared on the Internet that creates mazes
with walls placed at totally random angles. Sample picture. The algorithm is
based on extending the wall by a small segment at a time without crossing over
a pre-existing one. Algorithm detail. The disadvantage of this algorithm is
that the number of tests for intersection is O(E2), where E is the number of
line segments being drawn.

## [edit] See also

  * Mazes
  * Maze solving algorithm

## [edit] External links

  * Think Labyrinth: Maze algorithms (details on these and other maze generation algorithms)
  * Explanation of an Obfuscated C maze algorithm (a program to generate mazes line-by-line, obfuscated in a single physical line of code)
  * Maze generation and solving Java applet
  * Maze generator and solver, in C# \- print out mazes in various shapes on paper.
  * A simple method of making a circular maze

Retrieved from "http://en.wikipedia.org/wiki/Maze_generation_algorithm"

Categories: Mazes | Algorithms | Random graphs

Hidden categories: Cleanup from December 2006 | All pages needing cleanup

##### Views

  * Article
  * Discussion
  * Edit this page
  * History

##### Personal tools

  * Log in / create account

##### Navigation

  * Main page
  * Contents
  * Featured content
  * Current events
  * Random article

##### Search



##### Interaction

  * About Wikipedia
  * Community portal
  * Recent changes
  * Contact Wikipedia
  * Donate to Wikipedia
  * Help

##### Toolbox

  * What links here
  * Related changes
  * Upload file
  * Special pages
  * Printable version
  * Permanent link
  * Cite this page

##### Languages

  * ×¢××¨××ª

Powered by MediaWiki

Wikimedia Foundation

  * This page was last modified on 1 May 2009, at 19:32 (UTC).
  * All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)   
Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S.
registered 501(c)(3) tax-deductible nonprofit charity.  

  * Privacy policy
  * About Wikipedia
  * Disclaimers



