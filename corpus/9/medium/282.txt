
# Sprite (computer graphics)

### From Wikipedia, the free encyclopedia

Jump to: navigation, search

<IMG>

This article has multiple issues. Please help improve the article or discuss
these issues on the talk page.

  * It does not cite any references or sources. Please help improve it by citing reliable sources. Tagged since September 2007.  

  * It may require general cleanup to meet Wikipedia's quality standards. Tagged since October 2007.  

  
In computer graphics, a sprite (also known by other names; see Synonyms below)
is a two-dimensional/three-dimensional image or animation that is integrated
into a larger scene.

Sprites were originally invented as a method of quickly compositing several
images together in two-dimensional video games using special hardware. As
computer performance improved, this optimization became unnecessary and the
term evolved to refer specifically to the two dimensional images themselves
that were integrated into a scene. That is, figures generated by either custom
hardware or by software alone were all referred to as sprites. As three-
dimensional graphics became more prevalent, the term was used to describe a
technique whereby flat images are seamlessly integrated into complicated
three-dimensional scenes.

## Contents

  * 1 History
    * 1.1 Hardware sprites
    * 1.2 Sprites by software
    * 1.3 Background
    * 1.4 Move to 3D
  * 2 Application
  * 3 Synonyms

  
## [edit] History

In the mid-1970s, Signetics devised the first video/graphics processors
capable of generating sprite graphics. The Signetics 2636 video processors
were first used in the 1976 Radofin 1292 Advanced Programmable Video System.

The Elektor TV Games Computer was the first PC capable of generating sprite
graphics, which Signetics referred to as "objects". The term "sprite" was
coined for the Texas Instruments TMS9918 [1].

During most of the 1980s, hardware speed was in the low, single-digit
megahertz and memory was measured in kilobytes. Beside CISC processors, all
chips are hardwired. Sprites are rare in most video hardware today.

The CPU can instruct the external chips to fetch source images and integrate
them into the main screen using direct memory access channels. Calling up
external hardware, instead of using the processor alone, greatly improved
graphics performance. Because the processor is not occupied by the simple task
of transferring data from one place to another, software can run faster; and
because the hardware provided certain innate abilities, programs that use CISC
or BIOS were also smaller.

Separate locations in memory were used to hold the main display and the
sprites. Some sprite engines could only store a small amount of positions in
their registers and the unchallenged CPU was programmed to update them several
times per frame. Software blitting was complicated by some very strange
addressing modes into video ram.

### [edit] Hardware sprites

In early video gaming, sprites were a method of integrating unrelated bitmaps
so that they appear to be part of a single bitmap on a screen.

Many early graphics chips had true spriting use capabilities in which the
sprite images were integrated into the screen, often with priority control
with respect to the background graphics, at the time the video signal was
being generated by the graphics chip. This improved performance greatly since
the sprite data did not need to be copied into the video memory in order to
appear on the screen, and further since this spared the programmer of the task
of having to save and restore the underlying graphics, something which
otherwise was needed if the programmer chose to progressively update.

The sprite engine is a hardware implementation of scanline rendering. For each
scanline the appropriate scanlines of the sprites are first copied (the number
of pixels is limited by the memory bandwidth and the length of the horizontal
retrace) into very fast, small, multiple (limiting the # of sprites on a
line), and costly caches (the size of which limit the horizontal width) and as
the pixels are sent to the screen, these caches are combined with each other
and the background. It may be larger than the screen and is usually tiled,
where the tile map is cached, but the tile set is not. For every pixel, every
sprite unit signals its presence onto its line on a bus, so every other unit
can notice a collision with it. Some sprite engines can automatically reload
their "sprite units" from a display list. The sprite engine has synergy with
the palette. To save registers, the height of the sprite, the location of the
texture, and the zoom factors are often limited. On systems where the word
size is the same as the texel there is no penalty for doing unaligned reads
needed for rotation. This leads to the limitations of the known
implementations:

Sprite Hardware Features Computer, chip Sprites on screen Sprites on line Max
texels on line Texture width Texture height Colors Hardware Zoom Rotation
Background Collision detection Transparency Source  
Amiga, Denise display list 8 ? 16 arbitrary 3,15 vertical by display list No 2
bitmap layers Yes color key  
Amiga(AGA), Lisa display list 8 ? 16,32,64 arbitrary 3,15 vertical by display
list No 2 bitmap layers Yes color key  
Atari, ANTIC display list 4 ? 2,8 128, 256 1,3 1,2x vertical, 1,2,4x
horizontal No 1 tile or bitmap layer Yes color key [2]  
C64, VIC-II display list run by CPU 8 ? 12,24 21 1,3 1x 2x integer No 1 tile
or bitmap layer Yes color key [3]  
Game Boy 40 10 80 8 8,16 3 No No 1 tile layer No color key [4]  
GBA 128 128 1210 8,16,32,64 8,16,32,64 15,255 Affine Affine 4 layers, 2 layers
+ 1 affine layer, 2 affine layers No color key, blending [5]  
NES, RP2C0x 64 8 64 8 8,16 3 No No 1 tile layer Partial color key [6]  
Neo Geo 384 96 1536 16 Up to 512 15 sprite shrinking No No No color key .  
Out Run, dedicated hardware 128 32 ? 8 8 ? Anisotropic No 3 tile layers ?
alpha [7], [8]  
PC Engine, HuC6270A 64 16 256 16,32 16,32,64 15 No No 1 tile layer Yes color
key  
Sega Master System  
Sega Game Gear 64 8 64 8 8,16 15 No No 1 tile layer Yes color key [9]  
Sega Mega Drive 80 20 320 8,16,24,32 8,16,24,32 15 No No 2 tile layers ? color
key [10]  
SNES 128 34 272 8,16,32,64 8,16,32,64 15 background only background only
affine mapped tiles ? color key, averaging  
Texas Instruments TMS9918 32 4 64 8,16 8,16 1 1x 2x integer No 1 tile layer
Partial color key [11]  
Yamaha V9938 32 8 ? ? ? 16 No No ? ? color key  
Computer, chip Sprites on screen Sprites on line Max texels on line Texture
width Texture height Colors Hardware Zoom Rotation Background Collision
detection Transparency Source  
  
Many third party graphics cards offered sprite capabilities. Sprite engines
often scale badly, starting to flicker as the number of sprites increases
above the number of sprite units, or uses more and more silicon as the
designer of the chip implements more units and bigger caches.

### [edit] Sprites by software

Many popular home computers of the 1980's lack any support for sprites by
hardware. The animated characters, bullets, pointing cursors, etc. for
videogames (mainly) were rendered exclusively with the CPU by software, as
part of the screen video memory in itself. Hence the term software sprites.

Mainly, two distinct techniques were used to render the sprites by software,
depending on the display hardware characteristics:

  * Binary image masks, mainly for systems with bitmapped video frame buffers. It implies the use of an additional binary mask for every sprite displayed.
  * Transparent color, mainly for systems with indexed color displays. It implies that the "transparent" pixels use a concrete palette entry color, specifically reserved for this purpose by the program.

### [edit] Background

<IMG>

<IMG>

Example of a sprite.

No sprite engine was implemented which would not cache the sprites texels, but
use a FIFO at the pixel-output instead. This would allow sprites of arbitrary
width. So while blitter based hardware uses a unified model for foreground and
background and a fixed flat frame-buffer, sprites need a special background
engine. It has to provide scrolling backgrounds for tile-based games and
pseudo-3D (mode 7) backgrounds.

A similar discrimination is known from software rendering. A technique called
"dirty rectangles" is used to redraw only those parts that have changed since
the last repainted and a scrolling frame buffer is used. On more powerful CPUs
the whole frame-buffer is flat and redrawn completely.

### [edit] Move to 3D

Prior to the popularizing of true 3D graphics in the late 1990s, many 2D games
attempted to imitate the look of three-dimensionality with a variety of sprite
production methods. These included:

  * Rotoscoping: The filmed performances of live actors were sometimes used for creating sprites, most famously in the case of Prince of Persia which added a relative element of realism to a platform game. The method was used in a number of other fighting games, mostly in the mid 90s.
  * Claymation or the use of posable models which were used for characters that could not be portrayed by actors. Famous early examples include Goro of Mortal Kombat and various enemies from Doom. Used to a greater extent in games like Clay Fighter.
  * Pre-rendered CGI models: Introduced by Rise of the Robots and later used to a great extent in PC real-time strategy and RPG games prior to the move to true 3D. Since computers of the day could not run complex 3D graphics, footage of pre-rendered three-dimensional character models were often used which created a (relative) illusion of 3D.

More often sprite now refers to a partially transparent two dimensional
animation that is mapped onto a special plane in a 3D scene. Unlike a texture
map, the sprite plane is always perpendicular to the axis emanating from the
camera. The image can be scaled to simulate perspective, rotated two
dimensionally, overlapped with other objects, and be occluded, but it can only
be viewed from the same angle. This rendering method is also referred to as
billboarding.

Sprites create an effective illusion when

  * the image inside the sprite already depicts a three dimensional object;
  * the animation is constantly changing or depicts rotation;
  * the sprite exists only shortly;
  * the depicted object has a similar appearance from many common viewing angles (such as something spherical);
  * the viewer accepts that the depicted object only has one perspective (such as small plants or leaves).

When the illusion works, viewers will not notice that the sprite is flat and
always faces them. Often sprites are used to depict phenomena such as fire,
smoke, small objects, small plants (like blades of grass), or special symbols
(like "1-Up"). The sprite illusion can be exposed in video games by quickly
changing the position of the camera while keeping the sprite in the center of
the view. Sprites are also used extensively in particle effects and commonly
represented pickups in early 3D games especially.

An example of extensive usage of sprites to create the illusion is the game
The Elder Scrolls IV: Oblivion, whose main graphical feature was the ability
to display hundreds, if not thousands of animated trees on-screen at one time.
Closer inspection of those trees reveals that the leaves are in fact sprites,
and rotate along with the position of the user. However, this fact is only
revealed when the player actually examines the trees up-close, and rotates the
camera.

Sprites have also occasionally been used as a special-effects tool in movies.
One such example is the fire breathing Balrog in The Lord of the Rings: The
Fellowship of the Ring; the effects designers utilized sprites to simulate
fire emanating from the surface of the demon. Small bursts of fire were filmed
in front of a black background and made transparent using a luma key. Many
bursts were then attached to the surface of the animated Balrog model and
mixed with simulated smoke and heat waves to create the illusion of a monster
made from fire.

The term "sprite" is often confused with low resolution 2D graphics drawn on a
computer, also known as pixel art. However, sprite graphics (bitmaps) can be
created from any imaginable source, including prerendered CGI, dynamic 3D
graphics, vector art, and even text. Likewise, pixel art is created for many
purposes other than as a sprite, such as video game backgrounds, textures,
icons, websites, display art, comics, and t-shirts.

With the advancement in computer graphics and improved power and resolution,
actual pixel art sprites are becoming increasingly infrequent outside of
handheld game systems and cell phones.

## [edit] Application

Sprites are typically used for characters and other moving objects in video
games. They have also been used for mouse pointers and for writing letters to
the screen. For on-screen moving objects larger than one sprite's extent,
sprites may sometimes be scaled and/or combined.

Billboarding is one term used to describe the use of sprites in a 3D
environment. In the same way that a billboard is positioned to face drivers on
a highway, the 3D sprite always faces the camera. There is both a performance
advantage and an aesthetic advantage to using billboarding. Most 3D rendering
engines can process "3D sprites" much faster than other types of 3D objects.
So it is possible to gain an overall performance improvement by substituting
sprites for some objects that might normally be modeled using texture mapped
polygons. Aesthetically sprites are sometimes desirable because it can be
difficult for polygons to realistically reproduce phenomena such as fire. In
such situations, sprites provide a more attractive illusion.

## [edit] Synonyms

Major video game companies rarely (if at all) use the term "sprite" in the
general public. Some other alternatives that have been used are:

  * Player-Missile Graphics was used on the Atari 400/800 and Early Atari Coin Op games to refer to hardware-generated sprites. The term reflected the usage for both characters ("players") and other objects ("missiles"). They had restricted horizontal resolution (8 or 2 pixels, albeit with scalability, and a potential 192 lines of vertical resolution), limiting their use somewhat.
  * Movable Object Block, or MOB was used in MOS Technology's graphics chip literature (data sheets, etc). However, Commodore, the main user of MOS chips and the owner of MOS for most of the chip maker's lifetime, applied the common term "sprite".
  * On the Nintendo Entertainment System, Super Nintendo Entertainment System, and Game Boy, sprites were referred to as OBJs (short for "objects"), and the region of RAM used to store sprite attributes and coordinates was known as OAM (Object Attribute Memory). This still applies today on the Game Boy Advance and Nintendo DS handheld systems.
  * BOB's or 'Blitter Objects', popular name for graphics objects drawn with the dedicated graphics blitter in the Amiga series of computers, which was available in addition to its true hardware sprites.
  * Software sprites were used to refer to subroutines that used bit blitting to accomplish the same goal on systems such as the Atari ST and the Apple II whose graphics hardware had no sprite capability.
  * The computer programming language DarkBASIC used the term Bob (for "blitter object") to refer to its software-sprite functions, before switching to the more conventionally-used "sprite" term.
  * 3D Sprite is a term often used to refer to sprites that are essentially texture mapped 3D facets that always have their surface normal facing into the camera.
  * Z-Sprite is a term often used for 3D environments that contain only sprites. The Z-parameter provides a scaling effect that creates an illusion of depth. For example in adventure games such as King's Quest VI where the camera never moves, normal 2D sprites might suffice, but Z-sprites provide an extra touch.
  * Impostor is a term used instead of billboard if the billboard is meant to subtly replace a real 3D object.

Retrieved from "http://en.wikipedia.org/wiki/Sprite_(computer_graphics)"

Categories: Computer graphics data structures | Video game design

Hidden categories: Articles lacking sources from September 2007 | All articles
lacking sources | Cleanup from October 2007 | All pages needing cleanup

##### Views

  * Article
  * Discussion
  * Edit this page
  * History

##### Personal tools

  * Log in / create account

##### Navigation

  * Main page
  * Contents
  * Featured content
  * Current events
  * Random article

##### Search



##### Interaction

  * About Wikipedia
  * Community portal
  * Recent changes
  * Contact Wikipedia
  * Donate to Wikipedia
  * Help

##### Toolbox

  * What links here
  * Related changes
  * Upload file
  * Special pages
  * Printable version
  * Permanent link
  * Cite this page

##### Languages

  * Äesky
  * Dansk
  * Deutsch
  * EspaÃ±ol
  * FranÃ§ais
  * Italiano
  * Nederlands
  * âªNorsk (bokmÃ¥l)â¬
  * æ¥æ¬èª
  * Polski
  * PortuguÃªs
  * Ð ÑÑÑÐºÐ¸Ð¹
  * Suomi
  * Svenska

Powered by MediaWiki

Wikimedia Foundation

  * This page was last modified on 26 March 2009, at 13:50.
  * All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)   
Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S.
registered 501(c)(3) tax-deductible nonprofit charity.  

  * Privacy policy
  * About Wikipedia
  * Disclaimers



